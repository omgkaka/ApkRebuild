#Apk反编译&回编译（二）
---
###本篇主要讲解加固型apk反编译和回编译方法

1. 主要使用工具：adb ，gdb ， DumpAllDEX ， dex2jar

2. 工具用途详解： 
	 
        adb：安卓调试桥，安卓SDK里面附带的，用于安卓应用程序调试；
        gdb：二进制文件，主要用于linux内核调试，但这里使用的是手机端的gdb，因为是要调试安卓内核相关进程pid ；
		DumpAllDEX ： pc端exe执行文件，作用是将dex文件从调试出的进程pid文件中释放出来； 
		dex2jar: 主要是将dex文件转换为jar文件，这时候的jar即为反编译后的源码
	 
	
3. 实现原理分析： 所谓的加固将原有的dex隐藏在so文件中, 在运行时解压释放到内存, 并且通过修改app的类加载器的方式实现加固。 可以看出最终是要释放到内存，因此可以截取释放到内存中的dex文件即为我们需要的dex。 当然有的第三方加固提供了反调试功能，其实这个也是可以进行反编译的，这里不讲。  

4. Apk反编译之使用姿势   
这里使用xxx.apk（已加固，反编译的是真实项目，这里就稍微保护下） 作为反编译文件  
a. 确保已配置adb环境变量，将gdb文件push到模拟器或是手机中（需要root权限），此过程比较蛋疼，本人出于方便考虑，直接将gdb复制到已root手机内存/data/data/目录下   
b. 将xxx.apk安装到该root手机中，安装完毕直接打开该APP，不要退出该APP， 然后在pc端打开Terminal, 依次输入adb shell回车--> top 回车，出现许多数据并且短暂停留后按Ctrl+C 结束top命令，否则会一直top。 top命令主要是列出当前手机最上层的进程pid（不是特别准，有时候需要top多次），如图：  
![](http://i1.piimg.com/567571/9bd58a71b99bc18e.jpg)  
图中的列PID即为进程ID，Name即为进程名，安卓应用程序未在清单文件声明进程名的默认都是包名，比对前面几个Name值是否与xxx.apk的包名一致，一致则记下其对应的PID。这里出于保护考虑，不列出真实项目包名。  
c. 经过上面的操作已经获取到xxx.apk应用程序在该手机内核中的PID了，我这里的PID是4681， 这时候就要使用gdb来抓取PID文件。在Terminal终端进入gdb文件在手机中的目录，如果是第一使用，需要进行授权，输入su 进行授权，授权完毕，依次输入 cd /data/data/ 回车--> chmod 777 gdb 回车 --> ./gdb --pid 4681 回车  
![](http://p1.bpimg.com/567571/26b2386741bfa6e7.jpg)  
此时进入了gdb模式，也就是内核调试，待执行完毕 输入 gcore 回车 获取核心文件，如图：  
![](http://p1.bpimg.com/567571/c8baaab17312bb54.jpg)  
出现已保存的提示证明核心文件提取成功，如图：  
![](http://p1.bpimg.com/567571/d5cd21a38cd56826.jpg)  
注：此文件保存在了和gdb同一目录下，我这里是/data/data/core.4681  
d. 将上述core.4681文件复制到电脑某个文件夹下，我这里放在电脑D：\core.4681,打开DumpAllDEX程序，输入D：\core.4681回车，稍等几秒即操作完成，最后会在D盘下生成一个core.4681文件夹，里面就是PID4681所有相关的dex文件，如图：  
![](http://i1.piimg.com/567571/0a53700b2815b32d.jpg)  
![](http://i1.piimg.com/567571/d87e0ac9b7cf1d66.png)  
可以发现core.4681文件夹下有许多dex文件，哪一个才是xxx.apk的dex文件呢，总有一个是的！ 一般来说最后六个就是xxx.apk的全部dex文件，其中xxx.apk的源码dex文件在倒数第三个，其他的都是第三方加固的dex文件，因此我们只需要倒数第三个dex文件即可。  
e. 将上述dex文件通过dex2jar工具转为jar文件即可阅读源码。至此，反编译结束  

5. Apk回编译之使用姿势  
	下回分解
 


 
---

							Date: 2016.12.7
